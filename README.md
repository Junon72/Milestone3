
# Classapp

Classapp is an application to help dance teachers to plan and archive their dance classes. Part of the dance teachers job is to create classes with material for specific occasions, with specific goals and limitations, like the level of the students or needs of curriculum in mind. Whether they are teaching an open class, company class, workshop or school curriculum, the teachers often have to come up with a series of classes which thematically create a coherent experience for the dance students. In some cases the teachers work together, especially as part of school curriculums, which implies coordinated planning and information sharing.

The class material tends to accumulate with time and good material and well working classes can get lost and forgotten.The information and valuable insights regarding the experiences with the students can easily get lost with the classes. Especially when working with groups of students in schools, in order to help the students improve over time, notes and remarks from the past are most useful resource of feedback.

The teachers time is often limited and the time for planning, personal improvement and developing new ideas rarely paid. Sometimes, to come up with new material can be taxing and time consuming. Resorting to already tested material is often helpful and a huge time saver. Other times the teachers natuarally has to come up with something new when working with the same group of students for a longer period of time. And at times it is also good to change the habitual perspectives to not repeat the same material and ideas over and over. Revisiting the classes from the past can give new inspiration, help find new perspectives and gain new insights. Building a comprehensive archive of classes can thus be a time saver, but also a source of inspiration, reflection and a valuable tool in maintaining a vigorous and alive relationship to teaching art of dance.

Classapp provides the dance teachers an easy way to plan, store classes for future reference and to revisit already designed classes for inspiration.

Possible users types:

- A freelance teacher working with companies, schools and/or dance studios.
- A curriculum teacher in an educational institution/ permanent school staff.python3 app.py
- Recurring teacher in different educational institutions.
- Company teachers.

User stories:

1. I would like to be able to have my classes in one place where I can find them wherever I am - digital would be great so I don’t need to carry my paper scribbles with me and be guessing what I was writing.

2. I would like to be able to recall some of my classes from the past, which would give me an idea how my class has evolved and what kind of information was produced and shared - a bit like a diary, but easier to use - to give inspiration for new class designs.

3. Would be great to have a link to the videos from my classes at hand with a class to refresh my memory and to reflect upon what could I do differently or better.

4. I would need a way to archive my classes and be able to write detailed logs so I can follow the progress of my students over time and share some insights with my colleagues.

5. It would be handy to be able to easily design a series of classes for specific purposes, which I could then copy and modify depending on the goals at hand.

6. I would like to be able to store my classes so that I can find the best fit in each situation, depending on the level of the people I will be teaching, or even the size of the studio or amount of the expected participants. For example, when I need to teach a class with small adjustments to the usual exercise material to accommodate some situations, like a very small studio.

7. It would be practical to have the associated music tracks and playlists with links stored with the classes and exercises and possibility to write remarks, such as, this track is good for a slower tempo, or this is good energetic music to pump up the class etc.

8. I really need a way to organize the class information so I can look at the classes I have taught, with my notes and logs to set goals and make sensible long term planning.

9. I would like to have a tool that would structure and unify my class designs to make it easier to visit them later.

## Technologies Used

Technologies used building this project include,

- [VSCode](https://code.visualstudio.com/ "VSCode") IDE, is a source-code editor developed by Microsoft for Windows, Linux and macOS.
- [Balsamiq Mockups3](https://balsamiq.com/wireframes/desktop/) is a user interface design tool for creating wireframes.
- [Bootstrap](https://getbootstrap.com/ "Bootstrap") is a free and open-source CSS framework directed at responsive, mobile-first front-end web development.
- [Bson](http://bsonspec.org/ "Bson") is a computer data interchange format in JSON-like document that MongoDB uses when storing documents in collections.
- [Chrome Developer Tool](https://developers.google.com/web/tools/chrome-devtools "Chrome Developer Tool")s is a set of web developer tools built directly into the Google Chrome browser that help allow web developers to test and debug their code.
- [CSS3](https://developer.mozilla.org/en-US/docs/Archive/CSS3 "CSS3") is a style sheet language used for describing the presentation of a document written in a markup language like HTML.
- [Config](https://pypi.org/project/config/) is a module that allows a hierarchical configuration schemes within Python projects.
- [Flask](https://flask.palletsprojects.com/en/1.1.x/ "Flask") is a micro web framework written in
- [Flask Bcrypt](https://flask-bcrypt.readthedocs.io/en/latest/) is a Flask extension that provides bcrypt hashing utilities for your application.
- [Flask PyMongo](https://flask-pymongo.readthedocs.io/en/latest/) is a bridging tool between Flask and PyMongo.
- [Flask Session](https://pythonhosted.org/Flask-Session/) is an extension for Flask that adds support for Server-side Session to your application.
- [Git](https://git-scm.com/ "Git") is a distributed version-control system for tracking changes in source code during software development.
- [GitHub](https://github.com/ "GitHub") is a Web-based hosting service for version control using Git.
- [GitIgnore ](https://www.gitignore.io/ "GitIgnore ")is a free web service that help create .gitignore templates.
- [Heroku](https://www.heroku.com/ "Heroku") is a platform as a service (PaaS) that enables developers to build, run, and operate applications entirely in the cloud.
- [HTML5](https://html.com/html5/) is code that describes web pages.
- [JavaScript](https://www.javascript.com/ "JavaScript") is an interpreted programming language that conforms to the ECMAScript specifications and most commonly used scripting language for Web pages.
- [Jinja2](http://jinja.pocoo.org/ "Jinja2") is a web template engine for the Python programming language.
- [Python 3.7.6](https://www.python.org/ "Python 3.4.3") is an interpreted, high-level, general-purpose programming language.
- [PyMongo](https://api.mongodb.com/python/current/ "PyMongo") is a distribution tool for interacting with MongoDB database from Python.
- [Slack](https://slack.com/intl/en-nl/lp/three?utm_medium=ppc&utm_source=google&utm_campaign=d_ppc_google_western-europe_en_brand-hv&utm_term=slack&ds_rl=1249094&gclid=Cj0KCQiAs67yBRC7ARIsAF49CdWe8odCtapVb73H6AUvEA8OADzSxxCqgfdc43zlDNxxb3EX22dAhHgaAredEALw_wcB&gclsrc=aw.ds) is a cloud-based proprietary instant messaging platform.
- [Werkzeug](https://palletsprojects.com/p/werkzeug/ "Werkzeug") is a comprehensive WSGI web application library, used to build all sorts of end user applications such as blogs, wikis, or bulletin boards, not to mention user login and registration handling.

## Setting up IDE

### Working with VSCode and Python

The project was developed using [VSCode IDE](https://code.visualstudio.com/ "VSCode IDE") with Mac OS High Sierra operating system.
For the version control, the code was pushed to local git repository and then to [GitHub](https://github.com/ "GitHub") repository. The application was then autodeployed through [Heroku](https://www.heroku.com "Heroku") from the GItHub Master.

To work with python, Python3 library was first installed locally to the root directory with [Homebrew package manager](https://brew.sh/ "Homebrew package manager"). [Install Homebrew](https://brew.sh/#install "Install Homebrew") has instructions how to install brew to Mac.

To check if and which versio of Python you have installed (Mac comes Python2 preinstalled) globally, you can open the Terminal and type:

`$ python --version`  # this will give you the version of python2

 To see if you have Python3 installed, type:

 `$ python3 --version`

 I wrote the application using Python3.7.6

It is good to aknowledge the fact that [from 2020 January on, Python2 does not recieve further official support](https://wiki.python.org/moin/Python2orPython3 "from 2020 January on, Python2 does not recieve further official support"). Here you can find instructions [how to install the latest version of Python on your Mac](https://docs.python-guide.org/starting/install3/osx/ "how to install the latest version of Python, or to upgrade to Python3").

VSCode uses Python interpreter extensions to read Python code. Extensions include helpful features for the developers, such as [editing helpers, debugging, linting and testing.](https://code.visualstudio.com/docs/python/python-tutorial "editing helpers, debugging and linting.")

Application uses Python libraries and package modules to accomplish the needed functions. After setting up the IDE to your liking, and creating your working directory, but before starting to code and using Python modules, it is important to isolate your development environment. Otherwise, there might rise conflicts between different package versions you might use for different Python projects. Python3 comes with a build in tool 'venv' to create a [virtual environments](https://realpython.com/python-virtual-environments-a-primer/ "virtual environments") for this purpose.

To create a virtual environment in VSCode on Mac, in VSCode Terminal type:
`$ python3 -m .venv <file_name>`
This will create a virtual environment folder to the root directory of your project.
Often the files are named either env, venv or .venv.

The folder contains the following subfolders:

- bin: files that interact with the virtual environment
- include: C headers that compile the Python packages
- lib: a copy of the Python version along with a site-packages folder where each dependency is installed

To activate the virtual environement type:
`$ source <name_of_the_venv_file>/bin/activate`

This will activate the environment. After activation you will see the environment name in brakets front of the command line in which context the system now operates.

`(<name_of_the_venv_file>) $`

which I named .venv

Now the Python version is run from the virtual environment file, rather than from the global install and the Python packages imported using pip3 are isolated to the this environment only. From Python3.6 on this is the recommended method of using virtual environments.

**Testing:**

To test the Python installation and the environment path:

1. Create a test.py file in root directory
2. In test.py file write:

    '''python
    import sys
        # this line prints if python is installed correctly
        def greet(greetings_to):
        greeting = 'Hello, { }'.format(greetings_to)
        return greeting

        # this line will print out the current python path and the version of the python print(sys.executable)
        print(greet('World!'))
    '''

To run the file, type:

`$ python3 test.py`

You should see the following **output in your terminal:**

    ```python
    Hello, World!
    /<name_of_the_workspace>/<name_of_the_venv_file>/bin/python3
    ```

Python is installed and works correctly
The code runs in virtual environment context
**Test result: Passed**

To exit the environment type:
`$ deactivate` which will return back to the 'system' context

#### Setting up git for version control

Before establishing the connection to GitHub, I created a .gitignore with the help of [Gitignore](http://https://www.gitignore.io/ "gitignore") in order to avoid pushing Operating System, IDE, Programming language and virtual environment folders and files to the public domain.

After, I created a local git and then linked the project to GitHub. I have installed VSCode GitHub extension, which makes committing changes slightly easier, by skipping username and password inquiry with each new commit.

To initialize and add the files to a local git:

`(.venv) $ git init` # creates a git file for the project

`(.venv) $ git add .` # adds all the current files, excluding the files defined in .gitignore

`(.venv) $ git commit -m"Initial commit"` # commits the files to the git repository`

In GitHub create a new repository for the project.
To connect the project to a GitHub, by pushing the repositroy from the command line:

`(.venv) $ git remote add origin https://github.com/<username>/<repository_name>.git`

`(.venv) $ git push -u origin master`

#### Installing and testing Flask

To install Flask to your work environment, in Terminal type:

`(.venv) $ sudo pip3 install Flask`

*The system reports I am using older version of pip.*

    ```
    WARNING: You are using pip version 19.2.3, however version 20.0.2 is available.
    You should consider upgrading via the 'pip install --upgrade pip' command.
    ```

*After upgrade I run the code again.*

**Testing:**
To ensure the Flask is installed, type:

`(.venv) $ pip3 freeze --local`

This will tell which packages are currently installed.

**Test result: Passed**
Terminal output reads.

    ```
    Click==7.0
    Flask==1.1.1
    itsdangerous==1.1.0
    Jinja2==2.11.1
    MarkupSafe==1.1.1
    Werkzeug==1.0.0
    ```

#### Flask test script

In test.py I created a script to test the working of Flask in VSCode IDE.

    '''python
    # Functionalities to import from modules
    import os                   # Imports operating system dependent functionality.
    from flask import Flask     # Imports Flask class from flask module .
    app = Flask(__name__)       # An instance of Flask class construction.
    # Route Decorator
    @app.route('/')             # URL handled by main() route handler.
        def welcome():          # Defines a function that returns "Hello World".
        return "Welcome Flask!"
    if __name__ == '__main__':  # tells the global namespace __name__ is set to equal "__main__"

    # If conditional statement is satisfied
        app.run(host=os.environ.get('IP'),  
        # launches the Flask built-in development web server and   
        # gets the IP Address from the operating system.
            port=int(os.environ.get('PORT', 5000)), 
            debug=True)
            # Gets PORT we want to open, which in this case is set to 5000.
            # Enable reloader and debugger by setting it to True, 
            # which is the recommended value for the development phase
    '''

Run the script:

`(.venv) $ python3 test.py`

Terminal output:

    ```
    * Serving Flask app "test" (lazy loading)
    * Environment: production
        WARNING: This is a development server. Do not use it in a production deployment.
        Use a production WSGI server instead.
    * Debug mode: on
    * Running on http://#.0.0.#:5000/ (Press CTRL+C to quit) - I have hide the actual IP address with #!!
    * Restarting with stat
    * Debugger is active!
    * Debugger PIN: 263-007-180
    ```

Following the link (option + click) opens the browser and 'Welcome Flask" is rendered on the screen.

**Test result: Passed**
Now that I know flask is installed and works in the os as well, I created the actual application file app.py.
In the file I modified the message to Hello World!
I run app.py to confirm the code works proper.

**Testing the routes**
I created a new route to Classes page to test the routing decorator function and html.

I get an endpoint error message, because the Classes page doesn't exist yet.

**Test result: Failed**
To fix the error I created Classes page and run app.py again.
In address bar I add /about after the IP to navigate to the Classes page.

**Test result: Passed**
-routes work
-html works

## Working with templates

The html pages are routed via app.py in this phase.
To test the rendering tool, import render_template from flask and implement it to your code.

**Test result: Passed**
-The pages are now rendered via app.py

To work with dynamic data, I created an array of dummy classes and connected the data to the Home page using Python Jinja template management engine.

Dummy data:

    ```
    data = [
        {'class_name': 'Monday Groove',
        'class_description': 'Let it loose and sweat it out',
        'main_element': 'Shaky shake moves',
        'log_date': 'March 7, 2020'},
        {'class_name': 'Tuesday Tango',
        'class_description': 'Get down and dirty',
        'main_element': 'Roses and shiny shoes',
        'log_date': 'March 8, 2020'}
    ]
    ```
**Test result: Passed**
-the data is rendered dynamically on the home page

After testing that the routing works, I added own html page for the links in 'head' section, the navigation, and the scripts section and moved the section content into their own page. I gave the navigation some styling and tested that the sections render correctly.

**Test result: Passed**
-the links, navigation and scripts work as they should

## url_for

To avoid hard coding of URLs in flask, the href links can be routed using url_for module of flask.
After changing the css routing, I created the actual webpages the user can navigate to from the navigation bar,
and changed the href paths to url_for routes.

The data will be added dynamically to the Classes and Series pages. The paths in decorator in app.py, needs to be updated.

Testing the navigation and the data rendering, I followed the navigation link to Classes and Series pages.

**Test Result Classes page: Passed**
-the dummy data renders as expected on the Classes page

**Test Result Series Page: Fail**
Terminal output states.

    ```
    jinja2.exceptions.TemplateSyntaxError: Encountered unknown tag 'endfor'. Jinja was looking for the following tags:  'endblock'.
    ```

-I created a dummy data for series and run the test again.

**Test Result: Passed**
-Also the Series dummy data renders correctly.

I tested the rest of the navigation links in the navigation bar.

**Navigation Test Result: All Passed**
-Navigation link is routed to the correct pages, the pages and page title render correctly.

## Displaying Classes on classes.html

To display the classes user has created I used Materialize collapsible element. I tested the page with the dummy data, before connecting the MongonDB database to the project.

**Test Result: Passed**
-Dummy data renders correctly on the dynamically created Materialize element.
-The Collapsible element opens and closes correctly

## MongoDB Atlas

### Getting the MongoDB working together with Python

The application uses MongoDB Atlas cloud storage for storing the user data. An additional distribution tool PyMongo is needed to access MongoDB database with Python.  

To install PyMongo, in Terminal type:

`(.venv) $ sudo pip3 install pymongo`

Make sure you are operating in virtual environment context!

Terminal output:

`Successfully installed pymongo-3.10.1`

You also need to install flask-pymongo to connect your MongoDB database with Flask application to perform CRUD operations.

To install flask-bymogo, in Terminal type:

`(.venv) $ sudo pip3 install flask_pymongo`

Terminal output:

`Successfully installed flask-pymongo-2.3.0`

To comply with the newest connection string used by MongoDB, you also must install dnspython module which is a DNS toolkit for Python

To install dnspython, in Terminal type:

`(.venv) $ sudo pip3 install dnspython`

Terminal output:

`Successfully installed dnspython-1.16.0`

#### Preparing the IDE (VSCode in Mac OS)

#### Connecting the application

To connect an application to [MongoDB Atlas](https://www.mongodb.com/cloud/atlas) database, first you need to be registered. For registration follow the steps provided on the free starter [registration pages](https://www.mongodb.com/cloud/atlas/register), for creating account and deployment follow the instruction on [Getting Started with Atlas pages](https://docs.atlas.mongodb.com/getting-started/).

MongoDB has a practical dashboard utility where the user can create databases, and manage document collections in them.
In MongoDB dashboard I created a new cluster and a project context for Classapp and added a new database.
In the database I then created a new collection 'clasess' and in the classes collection a new 'class' document.

    ```python
    _id:ObjectId("5e519eb9ba2dfb000006dfe1")
    class_name:"Monday Groove"
    class_description:"Let it loose and sweat it out!"
    main_elements:"Shaky shake moves"
    other_elements:"Shovel the toes, Slide with grace"
    playlist_title:"Billie Eilish"
    playlist_url:"https://www.youtube.com/watch?v=xNV38nq1fqc"
    class_notes:"This class makes you SWEAT, bring water and a towel"
    exercises:Array
        0:Object
            _id:ObjectId("5e51a370ba2dfb000006dfe6")
            exercise_name:"Get it going"
            exercise_description:"Wiggle the toes, while you touch your nose"
            exercise_comment:"Slow cooking makes the best stew"
            exercise_aim:"Gets your toes moving, while maintaining focus to that which is the ne..."
            tracks:Array
                0:Object
                    _id:ObjectId("5e51a3ebba2dfb000006dfe7")
                    track_title:"Billie Eilish/ Bad Guy"
                    track_link:"https://www.youtube.com/watch?v=DyDfgMOUjCI"
                    track_comment:"It ain't salsa, but... I like Billie Eilish, ok"
            links:Array
                0:Object
                    _id:ObjectId("5e51a454ba2dfb000006dfe8")
                    video_title:"Say salsa/ Quick Feet Studio"
                    video_link:"https://www.youtube.com/watch?v=vfpajx2uemE"
                    video_comment:"The Quick & Dirty Guide to Salsa, Part 1. All the lessons put together..."
    logs:Array
        0:Object
            _id:ObjectId("5e51a32dba2dfb000006dfe5")
            log_date:"07/01/2020"
            log_text:"Was wonderful class. Remember to start slow and ALWAYS smile"
            log_tag:"1st class for DanceFloor"
    ```

To connect to the database, in MongoDB in the application CONTEXT Classapp and in the Clusters view, select CONNECT.
This will pop up a dialogue. To test the connection choose the Connect With Mongo Shell option.
With Mongo Shell installed, choose the right hand side option, and copy the provided link.
Paste the link to the Terminal, and modify the username part as appropriate.
You will be asked to enter the password.

If the connection is successful, the terminal output should be something along the line:

    ```
    Implicit session: session { "id" : UUID("dfie1392-7138-4662-9cf4-a271hf31f47f") }
    MongoDB server version: 4.2.3
    MongoDB Enterprise Cluster2-shard-0:PRIMARY>
    ```

## Preparing VSCode for MongoDB
To connect ot the cluster you need to have installed MongoDB Tap into your computer.
This you can do with Homebrew. In terminal write:

'$ brew tap mongodb/brew'

Then pour from the tap to install the latest MongoDB Community edition.

'$ brew install mongo-community'

To connect to the server from elswhere in your network you can install MongoDB Shell.

'$ brew install mongodb/brew/mongodb-community-shell

To start teh service type.

'$ brew services start mongodB'

### Connecting to MonogoDB Atlas from IDE terminal

In terminal we can now connect to to MongoDB byt typing.

'$ mongo mongo 'mongodb+srv://dbuser:dbpassword@cluster2-8wde6.mongodb.net/database?retryWrites=true&w=majority'

This should give a following terminal output:

    '''
    MongoDB shell version v4.2.2
    connecting to: mongodb://cluster2-shard-00-02-8wde6.mongodb.net:27017,cluster2-shard-00-01-8wde6.mongodb.net:27017,cluster2-shard-00-00-8wde6.mongodb.net:27017/classapp?authSource=admin&compressors=disabled&gssapiServiceName=mongodb&replicaSet=Cluster2-shard-0&retryWrites=true&ssl=true&w=majority
    2020-04-07T18:50:30.655+0200 I  NETWORK  [js] Starting new replica set monitor for Cluster2-shard-0/cluster2-shard-00-02-8wde6.mongodb.net:27017,cluster2-shard-00-01-8wde6.mongodb.net:27017,cluster2-shard-00-00-8wde6.mongodb.net:27017
    2020-04-07T18:50:30.657+0200 I  CONNPOOL [ReplicaSetMonitor-TaskExecutor] Connecting to cluster2-shard-00-00-8wde6.mongodb.net:27017
    2020-04-07T18:50:30.657+0200 I  CONNPOOL [ReplicaSetMonitor-TaskExecutor] Connecting to cluster2-shard-00-01-8wde6.mongodb.net:27017
    2020-04-07T18:50:30.657+0200 I  CONNPOOL [ReplicaSetMonitor-TaskExecutor] Connecting to cluster2-shard-00-02-8wde6.mongodb.net:27017
    2020-04-07T18:50:31.342+0200 I  NETWORK  [ReplicaSetMonitor-TaskExecutor] Confirmed replica set for Cluster2-shard-0 is Cluster2-shard-0/cluster2-shard-00-00-8wde6.mongodb.net:27017,cluster2-shard-00-01-8wde6.mongodb.net:27017,cluster2-shard-00-02-8wde6.mongodb.net:27017
    Implicit session: session { "id" : UUID("421af287-fa81-4bcf-a827-4f2a91525585") }
    MongoDB server version: 4.2.5
    MongoDB Enterprise Cluster2-shard-0:PRIMARY> 
    '''
To test the connection to the cluster type:

'$ show collections'

This gives the name of the collection in the cluster.

'classes'

**Test result: Passed**
-Mongo Shell connected to the Classapp database and the current collections in it.

### Pymongo

To be able to programmatically do CRUD operations install Pymongo library.

'$ sudo pip3 install dnspython'

And finally.

'$ sudo pip3 install pymongo'

To test that the libraries that are now installed type.

'$ pip3 freeze'

**Test result: Passed**
-dns and pymongo libraries were installed.

### Flask-Pymongo

To connect to the MongoDB with Flask application and perform CRUD operations you need to install also Flask-Pymongo.

'$ sudo pip3 install flask_pymongo'

**!! SECURITY !!**

It is important to make sure that the connection configurations with passwords and other connecions strings stay safely hidden from the user.
I put the MongoDB URI with the username and the password into a separate environment file config.py and added it to the .gitignore. The project uses Config module for the configuration schema.

To install Config, in Terminal type:
`(.venv) $ sudo pip3 install config`

Add the configuration module to your project with:
`from config import Config`

Create config.py file and add the configuration vars into the file:
    '''python
    # os is used to to link the config.py and app.py
    import os
    # the vars are stored into a class object
    class Config(object):
    # General config
    SECRET_KEY = os.environ.get('SECRET_KEY', 'secret_key')
    FLASK_APP = os.environ.get('FLASK_APP')
    # Database config
    MONGO_URI = os.environ.get('MONGO_URI', 'mongodb+srv://db_user:db_password@cluster2-8wde6.mongodb.net/database_name?retryWrites=true&w=majority')
    MONGO_DBNAME = os.environ.get('database')
    '''

To test Flask connection to the MongoDB I used following test in test.py environment:

    '''ptyhon
    import os                  
    import pymongo
    from pymongo import MongoClient
    from flask import Flask, render_template, redirect, request, url_for
    from config import Config
    from flask_pymongo import PyMongo
    from bson.objectid import ObjectId

    app = Flask(__name__) 
    app.config.from_object(Config)     

    MongoDB name
    app.config['MONGO_DBNAME'] = 'classapp'
    MongoDB URI / Assign db
    client = MongoClient(Config.MONGO_URI)
    db = client.classapp


    mongo = PyMongo(app)

    # MONGO CONNECTION TEST
    def mongo_connect(url):
        try:
            conn = pymongo.MongoClient(url)
            print("Mongo is connected!")
            return conn
        except pymongo.errors.ConnectionFailure as e:
            print('Could not connect to MongoDB: %s') % e

    conn = mongo_connect(MONGO_URI)
    '''

**Test result: Passed**
-Mongo is connected!

### Adding to the collections

To add collections to your database, in MongoDB dashboard click on **Collections**.
Then add collection name and click **Create**.

## Heroku

### Heroku and VSCode

To use Heroku with VSCode, I installed Heroku and Herko-cli extensions from the VSCode market place.

### Deployment procedure for [Heroku](https://www.heroku.com/ "Heroku") hosting site

To begin with deployment on Heroku go to [Heroku landing page](https://www.heroku.com/ "Heroku"). There you will find an option to either Sign in or Sign up.  If you have not signed up for Heroku platform before you can start here, otherwise you can continue from Login.

#### Signing up to Heroku

- On [Heroku](https://www.heroku.com/ "Heroku") Sign up.
- Complete the form presented to you. In at the ned ogf the form, in Primary development language dropdown, select Python.
- After submitting the form you will receive a confirmation email asking you to confirm you newly created Heroku account. (It can take some time before the email arrives - up to 15min.)
- To activate the account, follow the link and  after creating a password click the button to proceed.

#### Login to Heroku

- On your dashboard, select **New** and **Create new app**
- Create **App name**, then **Choose your region**, and finally click **Create app**

-Before deploying you project , you have to have created requirements.txt file and Procfile file in you project DOM. Also the Config variables have to be set*

Now that you have created Heroku space for you application, in your IDE (I used VSCode for this project) prepare you project for the deployment.

### Connecting to Heroku and creating the app

After login you can directly connect to Heroku by typing.

'$ heroku apps'

**Test result: passed**
Terminal output is my email address I have created the Heroku account with followed by 'Apps', and list of applications in my Heroku account.

Next, create the app in Heroku by typing.

'$ heroku create app_name' using the name of your application in place of app_name.

**Test result: passed**
    '''
    Creating ⬢ flask-classapp... done
        https://flask-classapp.herokuapp.com/ | https://git.heroku.com/flask-classapp.git
    '''
Test the operation by typing

'$ git remote -v'

This will add a new remote.

**Test result: passed**
    '''
    heroku  https://git.heroku.com/flask-classapp.git (fetch)
    heroku  https://git.heroku.com/flask-classapp.git (push)
    origin  https://github.com/Junon72/Milestone3.git (fetch)
    origin  https://github.com/Junon72/Milestone3.git (push)
    '''

Since I have set my VSCode working environment to use GitHub for version control it is added automatically.
Otherwise you will see only Heroku git address.

### Adding Procfile and requirements file

Before adding the Procfile you need to install gunicorn. 

'$ pip3 install gunicorn'

Then create Procfile in your base directory (just Procfile, with no extension!).
This specifies the commands that are executed by the on startup for Heroku.
In Procfile type.

'web gunicorn your_python_file_name:app' 

(your_python_file_name is written without the .py extension in this case!)

After creating Procfile, create the requirements.txt file.

'$ pip3 freeze --local > requirements.txt'

### Commit and open the application

At this point commit and push the application to Heroku.

'$ git add .'

'$ git commit -m"your_commit_message"

'$ git push heroku master'

You should see now Heroku deploying the app and verifying it.

**Test result: passed**
    '''
    remote: Verifying deploy... done.
    address_to_heroku_application_git
    * [new branch]      master -> master

## Open the application and finish the configuration in Heroku

After this you can go to your Heroku account and open your application. On right upper corner you find a button **Open app**. Click the button.

**Test result: passed**
The application opens in a browser window.
In Overview I have a message Build Succeeded and confirmation that the application is deployed and running.

To finish with Heroku configuration, in Heroku dashboard go to **Settings**. In settings you find a button **Reveal Config Vars**. Click the button.

On the Config Vars field KEY add IP and VALUE 0.0.0.0. Add another key value pair PORT 5000.
